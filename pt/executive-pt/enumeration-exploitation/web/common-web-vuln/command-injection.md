# Command Injection

**Command injection** is the abuse of an application's behaviour to execute commands on the operating system, using the same privileges that the application on a device is running with.

Command injection, often called **"Remote Code Execution" (RCE)**, lets attackers run code on a system remotely. This type of vulnerability is valuable for attackers because it allows them to directly interact with the system, such as accessing system or user files and data.



## Testing for Command Injection

You can often determine whether or not command injection may occur by the **behaviours of an application**. Then, **find the user input parameter** that will execute that command.

Applications that **use user input to populate system commands** with data can often be combined in unintended behaviour. For example, the shell operators `;`, `&` and `&&` will combine two (or more) system commands and execute them both.

```bash
/index.php?address=127.0.0.1;id
/index.php?address=127.0.0.1;cat+/etc/passwd
```

Command injection can be spotted in two main ways:

1. **Blind Command Injection**: Here, the application doesn't show any output directly. You need to observe the application's behavior to see if your command worked.
2. **Verbose Command Injection**: In this case, the application gives direct feedback. For instance, using the `whoami` command shows the user the application is running as, displaying the username right on the page.

### Test Blind Command Injection

* Use commands like `ping` and `sleep` to introduce delays. For example, `ping` will pause the application for _x_ seconds based on the number of _pings_.
* Another method of detecting blind command injection is by forcing some output. This can be done by using redirection operators such as `>`.  We can tell the web application to execute commands such as `whoami` and redirect that to a file. We can then use a command such as `cat` to read this newly created fileâ€™s contents.
* The `curl` command is a great way to test for command injection. This is because you are able to use `curl` to deliver data to and from an application in your payload.\
  &#x20;`curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami` .



### Test Verbose Command Injection

Detecting command injection this way is straightforward. Verbose command injection occurs when the app shows feedback or output. For instance, commands like `ping` or `whoami` show direct results on the web application.



### Payloads

#### Linux

```bash
whoami
ls
ping
sleep 
nc # for rev shell
```

#### Windows

```powershell
whoami
dir
ping
timeout
```

{% embed url="https://github.com/payloadbox/command-injection-payload-list" %}

## Bypassing Filtering

Applications use various methods to filter and clean data from user input. These filters limit you to specific actions, but it's possible to exploit the app's logic to dodge these filters. For instance, if an app removes quotation marks, you can use their hex value to get the same outcome. Although the data might look different, it still works as intended.



## Mitigations

### Vulnerable functions

Use the critical function in web application programming language **with the appropriate controls**.

Example of control: to limits the user input for pinging an IP we can use a regex like `[0-9]+`

Any application that uses these functions without proper checks will be vulnerable to command injection.

Examples of possible vulnerable function:

* **PHP**: Exec, Passthru, System
* **Flask**: subprocess.Popopen
* **Node**:  child\_process library

### Input Sanitisation

To prevent command injection, sanitize user inputs by defining acceptable data formats. For instance, restrict an input field to only accept numbers or automatically remove special characters like `>`, `&`, and `/`.

{% code title="PHP filter_input sanitisation" %}
```php
<?php
    if (!filter_input(INPUT_GET, "number", FILTER_VALIDATE_NUMBER)) {
    
    }
>
```
{% endcode %}



